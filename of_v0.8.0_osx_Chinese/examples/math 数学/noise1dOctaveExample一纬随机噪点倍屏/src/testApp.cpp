/*
 This example demonstrates how more "organic" noise signals
 can be generated by summing multiple "octaves" of noise.
 
 这个例子解释了如何得到更有机的噪点信号，通过总结多个噪点的“倍频程”（“octaves”）
 
*/

#include "testApp.h"

//--------------------------------------------------------------
void testApp::setup(){
	
	ofSetWindowTitle("Multiband Noise Example");
	ofSetVerticalSync(true);
	
	setupMultibandNoiseDemo();
}

//--------------------------------------------------------------
void testApp::update(){
	updateMultibandNoiseDemo();
}

//--------------------------------------------------------------
void testApp::draw(){
	ofBackgroundGradient( ofColor(240), ofColor(180), OF_GRADIENT_CIRCULAR);
	renderMultibandNoiseDemo();
}

//--------------------------------------------------------------
void testApp::setupMultibandNoiseDemo(){
	// setup and allocate resources used in the multi-noise strip demo.
	// 设置和定位用于创建多噪点条实例的资源
	nNoiseStrips = 8;
	sliderGroup.resize(nNoiseStrips); 
	noiseDataStripGroup.resize(nNoiseStrips); 
	
	originX = 100; 
	originY = 100; 
	float stripWidth	= 300;
	float stripHeight	= 35;
	float yMargin		= 5;
	float stripXPos		= originX;
	float stripYPos		= originY;
	float noiseStep		= 0.001;
	
	// These are the initial weights of the sliders, which 
	// multiply against their respective noise channels.
    // 这些是创建滑块的权重值，它的乘积影响它们所代表的噪点频道
	float noiseAmounts[8] = {0,0,0, 0.82,0.59,0.41, 0.06,0.17}; // fer example
	
	// I'm using a simple struct ("NoiseDataStrip", in testApp.h) to store the 
	// data contained by one of these noise recordings. Each struct contains
	// the bounding coordinates (x,y,w,h), and some other parameters, plus
	// the float array (data) containing the noise recordings. 
	// 我使用一个简单的结构（“NoiseDataStrip”在testApp.h）去存储这些噪点所包含的数据。
    // 每一个结构都包含一个边框的坐标（x,y,w,h）,和其他的一些参数，外加存储有噪点信息的浮点阵列(数据)。
	for (int i=0; i<nNoiseStrips; i++){
		noiseDataStripGroup[i].x = stripXPos;
		noiseDataStripGroup[i].y = stripYPos;
		noiseDataStripGroup[i].width = stripWidth;
		noiseDataStripGroup[i].height = stripHeight;
		noiseDataStripGroup[i].noiseStep = noiseStep; 
		noiseStep *= 2.0; 
		for (int j=0; j< NOISE_DATA_STRIP_LENGTH; j++){
			noiseDataStripGroup[i].data[j] = 1.0; 
		}
		
		float sliderX = stripXPos+stripWidth+yMargin;
		float sliderAmount = noiseAmounts[i]; //1.0 / (powf(2.0, i));
		sliderGroup[i].setup(sliderX, stripYPos, 16,stripHeight, 0.00, 1.0, sliderAmount, true,true);
		stripYPos += stripHeight + yMargin;
	}

}

//--------------------------------------------------------------
void testApp::updateMultibandNoiseDemo(){
	
	// For each noise strip
	for (int i=0; i<nNoiseStrips; i++){
		
		// Push the older data to the end of the array
		float *data = (float *)noiseDataStripGroup[i].data;
		for (int j=(NOISE_DATA_STRIP_LENGTH-1); j>0; j--){
			data[j] = data[j-1];
		}
		
		// Add the most recent data, the noise value. 
		// Here's where we actually fetch the noise, using ofNoise().
		// Note how ofNoise() requires an argument ('t'); this is
		// the coordinate (on a one-dimensional axis) whose
		// corresponding noise value we wish to obtain.
        
        //加入最近的数据，既噪点数值。
        //这里是我们真正取得噪点的地方，使用ofNoise().
        //注意如何使用ofNoise() 取得论据“（‘t‘）；
        //这是相对应于我们希望取得的噪点数值的坐标（在一纬的轴上）；
		float noiseStep = noiseDataStripGroup[i].noiseStep; 
		float t = (ofGetElapsedTimeMillis()/10.0 + i) * noiseStep;
		data[0] = ofNoise(t);
	}
	
	// Compute the normalization factor: the total sum of the weights
	// for all of the contributing noise channels. This number is the largest
	// value which the sum of noise streams could possibly achieve.
    // 计算出一个标准化因子：所有噪点频道的总值的权重。这个数字是噪点可以取得的最大值
	float normalizationFactor = 0;
	for (int i=0; i<nNoiseStrips; i++){
		float weight = sliderGroup[i].getValue();
		normalizationFactor += weight;
	}
	if (normalizationFactor == 0){
		normalizationFactor = 1.0;
	}
	
	// For every sample in the recording history,
    // 为了每一个记录样本
	for (int j=0; j<NOISE_DATA_STRIP_LENGTH; j++){
		float sumj = 0; 
		
		// Sum the weighted contribution from each of the noise strips.
        //相加每一个噪点条的权重
		for (int i=0; i<nNoiseStrips; i++){
			float val = noiseDataStripGroup[i].data[j];
			float weight = sliderGroup[i].getValue();
			sumj += (weight * val); 
		}
		
		// Normalize it to the range 0...1 by dividing it
		// by normalizationFactor, as we discussed above.
        //标准化它的范围到0-1之间通过除以一个标准因子，也就是我们上面讨论的东西。
		summedNoiseData[j] = sumj / normalizationFactor;
	}
	
	
}


//--------------------------------------------------------------
void testApp::renderMultibandNoiseDemo(){
	
	// draw the individual strips
    //画出每根条型
	float stackBottom = 0; 
	for (int i=0; i<nNoiseStrips; i++){
		float x = noiseDataStripGroup[i].x;
		float y = noiseDataStripGroup[i].y;
		float w = noiseDataStripGroup[i].width;
		float h = noiseDataStripGroup[i].height;
		stackBottom = y+h;
		
		float noiseStep = noiseDataStripGroup[i].noiseStep; 
		float *data = (float *) (noiseDataStripGroup[i].data);
		render1DNoiseStrip (x,y, w,h, noiseStep, data); 
	}
	
	// draw the strip containing the summed data.
    //画出条形所包含的数据总结
	render1DNoiseStrip(originX, stackBottom+125, 300,100, 0, (float *)summedNoiseData);
	
	string multiBandText   = "ofNoise() creates a signal that varies \n";
	multiBandText         += "smoothly between 0 and 1. More 'organic' \n";
	multiBandText         += "noise can be made by adding multiple \n";
	multiBandText         += "'octaves' of noise. The strip below shows \n";
	multiBandText         += "the sum of the above streams, weighted by \n";
	multiBandText         += "the values in their corresponding sliders. \n";	
	
	ofSetColor(0,0,0); 
	ofDrawBitmapString(multiBandText, originX,   stackBottom+33);
	ofDrawBitmapString("ofNoise()",   originX+1, stackBottom+33); //bold it
	
	ofDrawBitmapString("Noise Step", originX-46, originY-5);
	ofDrawBitmapString("Weights", originX+300+5, originY-5);
}


//--------------------------------------------------------------
void testApp::render1DNoiseStrip (float x, float y, float width, float height, float dt, float *data){
	
	ofPushMatrix();
	ofDisableSmoothing();
	ofEnableAlphaBlending();
	ofTranslate(x, y, 0); 
	
	// Yes, this is a drop shadow
    // 没错，这是在画阴影
	ofFill();
	ofSetColor(0,0,0, 10); 
	ofRect(0,0, width+4, height+2);
	ofRect(0,0, width+2, height+4); 
	
	// Draw a white box underneath the strip
    //画一个白色的盒子放在条形下面
	ofFill();
	ofSetColor(255,255,255); 
	ofRect(0,0, width, height); 
	
	// Draw a filled gray noise terrain.
    // 画一个填充成灰色的噪点地形
	ofEnableSmoothing();
	ofFill();
	ofSetColor(190); 
	ofBeginShape();
	ofVertex(width, height);
	for (int i=0; i<NOISE_DATA_STRIP_LENGTH; i++){
		float px = ofMap(i, 0,(NOISE_DATA_STRIP_LENGTH-1), width,0); 
		float py = height * data[i];
		ofVertex(px,py);
	}
	ofVertex(0, height); 
	ofEndShape(true);
	
	// Draw the black line of the noise waveform
    // 画噪点波形的黑线
	ofNoFill();
	ofSetColor(0,0,0); 
	ofBeginShape();	
	for (int i=0; i<NOISE_DATA_STRIP_LENGTH; i++){
		float px = ofMap(i, 0,(NOISE_DATA_STRIP_LENGTH-1), width,0); 
		float py = height * data[i];
		ofVertex(px,py);
	}
	ofEndShape(false);
	
	// Draw a box outline on top, around everything
    // 在顶部画一个盒装外框，包围所有东西
	ofDisableSmoothing();
	ofNoFill();
	ofSetColor(0,0,0); 
	ofRect(0,0, width, height);
	
	// Draw the dt noise-step factor
    // 画出噪点系数因子
	if (dt > 0){
		ofSetColor(0,0,0); 
		string label = ofToString(dt);
		ofDrawBitmapString(label, -46, height/2+6);
	}

	ofPopMatrix();
}

// In case you're wondering, the simpleSliders get their mouse info through event handlers.
// 如果你想知道的话，simpleSliders这个插件通过直接通过鼠标事件处理程序来获取鼠标信息。

//--------------------------------------------------------------
void testApp::keyPressed(int key){

}

//--------------------------------------------------------------
void testApp::keyReleased(int key){

}

//--------------------------------------------------------------
void testApp::mouseMoved(int x, int y){

}

//--------------------------------------------------------------
void testApp::mouseDragged(int x, int y, int button){

}

//--------------------------------------------------------------
void testApp::mousePressed(int x, int y, int button){

}

//--------------------------------------------------------------
void testApp::mouseReleased(int x, int y, int button){

}

//--------------------------------------------------------------
void testApp::windowResized(int w, int h){

}

//--------------------------------------------------------------
void testApp::gotMessage(ofMessage msg){

}

//--------------------------------------------------------------
void testApp::dragEvent(ofDragInfo dragInfo){ 

}
